services:
  chain:
    container_name: chain
    build: { context: chain }
    ports: ["${CHAIN_RPC_PORT}:8545"]
    volumes:
      - chain-data:/data
    healthcheck: { interval: 1s, retries: 10, test: cast block }
    stop_grace_period: 30s
    restart: on-failure:3
    environment:
      - FORK_RPC_URL=${FORK_RPC_URL:-}

  block-explorer:
    container_name: block-explorer
    build: { context: block-explorer, args: { RPC_URL: http://localhost:8545 } }
    depends_on:
      chain: { condition: service_healthy }
    ports: ["${BLOCK_EXPLORER_PORT}:3000"]

  ipfs:
    container_name: ipfs
    image: ipfs/kubo:v0.38.2
    ports: ["${IPFS_RPC_PORT}:5001"]
    volumes:
      - ipfs-data:/data/ipfs
    environment:
      IPFS_PROFILE: server
    healthcheck: { interval: 1s, retries: 50, test: ipfs id }
    restart: on-failure:3

  postgres:
    container_name: postgres
    image: postgres:17-alpine
    ports: ["${POSTGRES_PORT}:5432"]
    command: postgres -c 'max_connections=1000' -c 'shared_preload_libraries=pg_stat_statements'
    volumes:
      - postgres-data:/var/lib/postgresql/data
      - ./postgres/setup.sql:/docker-entrypoint-initdb.d/setup.sql:ro
    environment:
      POSTGRES_INITDB_ARGS: "--encoding UTF8 --locale=C"
      POSTGRES_HOST_AUTH_METHOD: trust
      POSTGRES_USER: postgres
    healthcheck: { interval: 1s, retries: 20, test: pg_isready -U postgres }
    restart: on-failure:3

  graph-node:
    container_name: graph-node
    build:
      context: "graph-node"
      args:
        GRAPH_NODE_VERSION: ${GRAPH_NODE_VERSION}
    depends_on:
      chain: { condition: service_healthy }
      ipfs: { condition: service_healthy }
      postgres: { condition: service_healthy }
    stop_signal: SIGKILL
    ports:
      - ${GRAPH_NODE_GRAPHQL_PORT}:8000
      - ${GRAPH_NODE_ADMIN_PORT}:8020
      - ${GRAPH_NODE_STATUS_PORT}:8030
      - ${GRAPH_NODE_METRICS_PORT}:8040
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro
    healthcheck:
      { interval: 1s, retries: 20, test: curl -f http://127.0.0.1:8030 }
    restart: on-failure:3

  graph-contracts:
    container_name: graph-contracts
    build:
      context: graph-contracts
      args:
        CONTRACTS_COMMIT: ${CONTRACTS_COMMIT}
        TAP_CONTRACTS_COMMIT: ${TAP_CONTRACTS_COMMIT}
    depends_on:
      chain: { condition: service_healthy }
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config
    environment:
      - FORK_RPC_URL=${FORK_RPC_URL:-}

  block-oracle:
    container_name: block-oracle
    build:
      context: block-oracle
      args:
        BLOCK_ORACLE_COMMIT: ${BLOCK_ORACLE_COMMIT}
    depends_on:
      graph-contracts: { condition: service_completed_successfully }
    stop_signal: SIGKILL
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro
    environment:
      RUST_BACKTRACE: full
    healthcheck:
      {
        interval: 1s,
        retries: 600,
        test: curl -f http://127.0.0.1:9090/metrics,
      }
    restart: on-failure:3

  indexer-agent:
    container_name: indexer-agent
    build:
      context: indexer-agent
      args:
        INDEXER_AGENT_VERSION: ${INDEXER_AGENT_VERSION}
    platform: linux/amd64
    depends_on:
      graph-contracts: { condition: service_completed_successfully }
    ports: ["${INDEXER_MANAGEMENT_PORT}:7600"]
    stop_signal: SIGKILL
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro
    healthcheck:
      { interval: 10s, retries: 600, test: curl -f http://127.0.0.1:7600/ }
    restart: on-failure:3

  subgraph-deploy:
    container_name: subgraph-deploy
    build:
      context: subgraph-deploy
      args:
        NETWORK_SUBGRAPH_COMMIT: ${NETWORK_SUBGRAPH_COMMIT}
        TAP_SUBGRAPH_COMMIT: ${TAP_SUBGRAPH_COMMIT}
        BLOCK_ORACLE_COMMIT: ${BLOCK_ORACLE_COMMIT}
    depends_on:
      graph-contracts: { condition: service_completed_successfully }
      graph-node: { condition: service_healthy }
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro

  start-indexing:
    container_name: start-indexing
    build: { context: start-indexing }
    depends_on:
      subgraph-deploy: { condition: service_completed_successfully }
      indexer-agent: { condition: service_healthy }
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro

  redpanda:
    container_name: redpanda
    image: docker.redpanda.com/redpandadata/redpanda:v23.3.5
    ports:
      - ${REDPANDA_KAFKA_PORT}:9092
      - ${REDPANDA_KAFKA_EXTERNAL_PORT}:29092
      - ${REDPANDA_ADMIN_PORT}:9644
      - ${REDPANDA_PANDAPROXY_PORT}:8082
      - ${REDPANDA_SCHEMA_REGISTRY_PORT}:8081
    command:
      - redpanda start
      - --smp 1
      - --memory 1G
      - --mode dev-container
      - --default-log-level=info
      - --kafka-addr=INTERNAL://0.0.0.0:9092,EXTERNAL://0.0.0.0:29092
      - --advertise-kafka-addr=INTERNAL://redpanda:9092,EXTERNAL://localhost:29092
      - --pandaproxy-addr 0.0.0.0:8082
      - --schema-registry-addr 0.0.0.0:8081
    volumes:
      - redpanda-data:/var/lib/redpanda/data
    healthcheck:
      {
        interval: 1s,
        retries: 600,
        test: rpk topic list --brokers="localhost:9092",
      }
    restart: on-failure:3

  tap-aggregator:
    container_name: tap-aggregator
    build:
      context: tap-aggregator
      args:
        TAP_AGGREGATOR_VERSION: ${TAP_AGGREGATOR_VERSION}
    depends_on:
      graph-contracts: { condition: service_completed_successfully }
    ports: ["${TAP_AGGREGATOR_PORT}:7610"]
    stop_signal: SIGKILL
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro
    environment:
      RUST_LOG: info,tap_aggregator=trace
      RUST_BACKTRACE: 1
    restart: on-failure:3

  tap-escrow-manager:
    container_name: tap-escrow-manager
    build:
      context: tap-escrow-manager
      args:
        TAP_ESCROW_MANAGER_COMMIT: ${TAP_ESCROW_MANAGER_COMMIT}
    depends_on:
      subgraph-deploy: { condition: service_completed_successfully }
      redpanda: { condition: service_healthy }
    stop_signal: SIGKILL
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro
    environment:
      RUST_LOG: info,tap_escrow_manager=trace
      RUST_BACKTRACE: 1
    restart: on-failure:3

  gateway:
    container_name: gateway
    build:
      context: gateway
      args:
        GATEWAY_COMMIT: ${GATEWAY_COMMIT}
    depends_on:
      indexer-service: { condition: service_healthy }
      redpanda: { condition: service_healthy }
    ports: ["${GATEWAY_PORT}:7700"]
    stop_signal: SIGKILL
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro
    environment:
      RUST_LOG: info,graph_gateway=trace
      RUST_BACKTRACE: 1
    restart: on-failure:3
    healthcheck:
      { interval: 1s, retries: 100, test: curl -f http://127.0.0.1:7700/ }

  indexer-service:
    container_name: indexer-service
    build:
      target: "wrapper" # Set to "wrapper-dev" for building from source
      context: indexer-service
      args:
        INDEXER_SERVICE_RS_VERSION: ${INDEXER_SERVICE_RS_VERSION}
    depends_on:
      indexer-agent: { condition: service_healthy }
      subgraph-deploy: { condition: service_completed_successfully }
    ports:
      - "${INDEXER_SERVICE_PORT}:7601"
    stop_signal: SIGKILL
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro
    environment:
      RUST_LOG: info,indexer_service_rs=trace
      RUST_BACKTRACE: 1
    healthcheck:
      { interval: 1s, retries: 100, test: curl -f http://127.0.0.1:7601/ }
    restart: on-failure:3

  tap-agent:
    container_name: tap-agent
    build:
      target: "wrapper" # Set to "wrapper-dev" for building from source
      context: indexer-service
      dockerfile: Dockerfile.tap-agent
      args:
        INDEXER_TAP_AGENT_VERSION: ${INDEXER_TAP_AGENT_VERSION}
    depends_on:
      indexer-agent: { condition: service_healthy }
      subgraph-deploy: { condition: service_completed_successfully }
    stop_signal: SIGKILL
    volumes:
      - ./config/shared:/opt/shared:ro
      - ./.env:/opt/config/.env:ro
      - ./config/local:/opt/config:ro
    environment:
      RUST_LOG: info,indexer_tap_agent=trace
      RUST_BACKTRACE: 1
    restart: on-failure:3

  ready:
    container_name: ready
    image: busybox:latest
    depends_on:
      start-indexing: { condition: service_completed_successfully }
      gateway: { condition: service_healthy }
    command: echo "Local network ready"

volumes:
  chain-data:
  postgres-data:
  ipfs-data:
  redpanda-data:
